from ast import pattern
from pathlib import Path
import sys
import os
import re
from typing import Literal
os.environ["R_HOME"] = "/home/luosg/miniconda3/envs/scRNAseq_rpy2_1/lib/R"
os.environ["PATH"] = "/home/luosg/miniconda3/envs/scRNAseq_rpy2_1/bin:" + os.environ.get("PATH", "")
os.environ["LD_LIBRARY_PATH"] = "/home/luosg/miniconda3/envs/scRNAseq_rpy2_1/lib:" + os.environ.get("LD_LIBRARY_PATH", "")
basePath = Path(__file__).resolve()
baseDir = basePath.parent
sys.path.append(str(baseDir / "utils"))
import anndata as ad
import numpy as np
import matplotlib.pyplot as plt
import logging
import pandas as pd
import scanpy as sc
import glob
from utils.TE import TEfamily
from rpy2.robjects.conversion import localconverter
import rpy2.robjects.packages as rpackages
import rpy2.robjects as ro
import rpy2.rinterface_lib.callbacks
from rpy2.robjects import pandas2ri
sc.settings.verbosity = 0
rpy2.rinterface_lib.callbacks.logger.setLevel(logging.ERROR)


logging.basicConfig(
    level=logging.INFO, 
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
# logging.debug("This is a debug message.") 
# logging.info("This is an info message.")
# logging.warning("This is a warning message.")
# logging.error("This is an error message.")
basePath = Path().resolve()
baseDir = basePath.parent
sys.path.append(str(baseDir / "utils"))
from utils.DEG_pseudo_bulk import Pre_AddAnnotations2RawCountsAnndata,Pre_PseduoBulk,Pre_FeatureRename,makePseudoBulk


def runEdgeRForCell(
    adata: ad.AnnData,
    cell: str,
    fig_dir: str,
    table_dir: str,
    out: str,
    DEGDesign:str,
    cell_type_key: str = "celltype",
    r_script_path: str = "/disk5/luosg/scRNAseq/workflow/scRNAseq/scripts/python/utils/DEG_pseduo_bulk.r"
) -> tuple[pd.DataFrame, pd.DataFrame]:
    """
    Performs pseudo-bulk differential gene expression (DEG) analysis for a specific cell type
    using a pre-defined R script and the rpy2 library.

    This function isolates a single cell type from an AnnData object, aggregates the data
    to a pseudo-bulk level, and then calls a master R function (`fit_model`) to handle the
    complete DEG analysis workflow, including filtering, normalization, model fitting,
    statistical testing, and saving plots and results.

    Args:
        adata (ad.AnnData): The input AnnData object containing single-cell data.
        cell (str): The specific cell type to be analyzed.
        fig_dir (str): The directory path to save diagnostic plots generated by the R script.
        table_dir (str): The directory path to save the differential expression results table.
        out (str): A base name for output files (plots and tables).
        DEGDesign (str): A character string defining the contrast for the DEG comparison in R.
                         e.g., "GroupA-GroupB".
        cell_type_key (str, optional): The key in `adata.obs` that contains the cell type
                                       annotations. Defaults to "celltype".
        r_script_path (str, optional): The full path to the R script containing the `fit_model`
                                       function. Defaults to a predefined path.

    Returns:
        tuple[pd.DataFrame, pd.DataFrame]: A tuple containing the prepared expression matrix
                                           (genes x cells) and metadata DataFrame for the
                                           subsetted cell type.

    Raises:
        KeyError: If the specified `cell_type_key` is not found in `adata.obs`.
        ValueError: If the specified `cell` type is not found in the `cell_type_key` column.
        rpy2.rinterface_lib.embedded.RRuntimeError: If the R script fails to load or if
                                                    R functions encounter a runtime error.
    """
    if cell_type_key not in adata.obs.columns:
        logging.error(f"The specified key '{cell_type_key}' is not found in adata.obs.")
        raise KeyError(f"Required key '{cell_type_key}' not found.")

    if cell not in adata.obs[cell_type_key].unique():
        logging.error(f"The specified cell type '{cell}' is not present in the data for key '{cell_type_key}'.")
        raise ValueError(f"Cell type '{cell}' not found in `adata.obs['{cell_type_key}']`.")

    logging.info(f"Subsetting data for cell type '{cell}' using key '{cell_type_key}'.")
    adata_mono = adata[adata.obs[cell_type_key] == cell].copy()

    X = adata_mono.X
    if hasattr(X, "toarray"):
        logging.info("Converting sparse matrix to a dense array.")
        X = X.toarray()
    
    expr_df = pd.DataFrame(
        X.T,  # edgeR and similar tools expect genes x cells
        index=adata_mono.var_names,
        columns=adata_mono.obs_names,
        dtype=np.float32  # Use a memory-efficient numerical type
    )
    logging.info(f"Expression matrix shape: {expr_df.shape}")

    coldata_df = adata_mono.obs.copy()

    try:
        coldata_df['replicate'] = coldata_df.index.to_series().str.extract(r'_([0-9]+)$')[0].astype(int)
    except KeyError:
        logging.warning("Could not extract 'replicate' from cell index. Check cell barcode format.")
        pass

    logging.info(f"Extracted metadata DataFrame with shape: {coldata_df.shape}")
    
    ro.r(f'source("{r_script_path}")')
    logging.info("Convert DataFrame from Python to R ")
    with localconverter(ro.default_converter + pandas2ri.converter):
        r_expr_df = ro.conversion.py2rpy(expr_df) # can't transpose
        r_coldata_df = ro.conversion.py2rpy(coldata_df)
    
    logging.info("Call R custom function fit_model to conduct differential gene analysis")
    fit_model_r_func = ro.globalenv['fit_model']
    outs = fit_model_r_func(
        r_expr_df,
        r_coldata_df,
        group_col="sample",
        DEGDesign=DEGDesign,
        out_prefix=out,
        fig_dir=fig_dir,
        table_dir=table_dir,
        replicate_col="replicate"
    )
    
    logging.info("Differential gene analysis complete")
    return expr_df, coldata_df

def DEGDesignGenerate(
        adata:ad.AnnData
):
    adata.obs['sample_celltype'] = adata.obs['sample'].astype(str) + '_' + adata.obs['celltype'].astype(str)
    grouped_by_celltype = adata.obs.groupby('celltype',observed=False)

    result_dict = {}
    for celltype, group in grouped_by_celltype:
        result_dict[celltype] = group['sample_celltype'].tolist()
        
    deduplicated_dict = {}
    for key, value_list in result_dict.items():
        unique_list = list(set(value_list))
        deduplicated_dict[key] = unique_list

    # print(deduplicated_dict)

    result_dict = {}

    # 遍历输入字典的每一项
    for cell_type, cell_list in deduplicated_dict.items():
        
        # 初始化一个空列表，用于存储当前 cell_type 的所有组合
        combinations = []
        
        # 筛选出每种类型的字符串
        cko_strings = [s for s in cell_list if s.startswith('CKO')]
        wt_strings = [s for s in cell_list if s.startswith('WT')]
        tra_strings = [s for s in cell_list if s.startswith('TRA')]
        e2_strings = [s for s in cell_list if s.startswith('E2')]

        # 生成 CKO-WT 组合
        for cko_s in cko_strings:
            for wt_s in wt_strings:
                combinations.append(f"combined_group{cko_s}-combined_group{wt_s}")
                
        # 生成 TRA-CKO 组合
        for tra_s in tra_strings:
            for cko_s in cko_strings:
                combinations.append(f"combined_group{tra_s}-combined_group{cko_s}")

        # 生成 E2-CKO 组合
        for e2_s in e2_strings:
            for cko_s in cko_strings:
                combinations.append(f"combined_group{e2_s}-combined_group{cko_s}")

        # 生成TRA-WT组合
        for tra_s in tra_strings:
            for wt_s in wt_strings:
                combinations.append(f"combined_group{tra_s}-combined_group{wt_s}")
        
        #生成E2-WT组合
        for e2_s in e2_strings:
            for wt_s in wt_strings:
                combinations.append(f"combined_group{e2_s}-combined_group{wt_s}")
        # 将生成的组合列表作为值，以 cell_type 为键存入结果字典
        result_dict[cell_type] = combinations
                
    print(result_dict)
    return result_dict

def main(
        adata:ad.AnnData,
        fig_dir:str,
        table_dir:str
):
    logging.info(ro.r('.libPaths()'))
    logging.info(ro.r('system.file(package = "edgeR")'))
    adata_design = DEGDesignGenerate(adata)
    for cell,designs in adata_design.items():
        for design in designs:
            logging.info(f"{cell}:{design}")
            pattern = r'combined_group(.*)_10XSC3_(.*)-combined_group(.*)_10XSC3_(.*)_DEG'
            match = re.match(pattern, design)
            if match:
                experiment = match.group(1)
                control = match.group(3)
                cell = match.group(2)
                outPrefix = f"{cell}_{experiment}_vs_{control}"
                expr_df,coldata_df = runEdgeRForCell(adata,
                                            cell = cell,
                                            fig_dir=fig_dir,
                                            table_dir=table_dir,
                                            out=outPrefix,
                                            DEGDesign=design)
            else:
                raise ValueError(f"DEGDesign {design} does not match expected pattern.")

def runVolcano(
        infile:str,
        out:str,
        mode:Literal["TE","Gene","None"] = "TE",
        TE:str = "/disk5/luosg/Reference/UCSC/mouse/mm39/rmsk_mm39.txt.gz",
        r_script_path: str = "/disk5/luosg/scRNAseq/workflow/scRNAseq/scripts/python/utils/volcano.r"
):
    logging.info("Begin read DEG result and rmsk file")
    df = pd.read_csv(infile,sep="\t")
    df["gene_name"] = df.index
    logging.info(f"mode: {mode}")
    if mode == "TE":
        TEfamily(DEG_file=infile,rmsk_file=TE,out=out)
        df_TE = pd.read_csv(TE,sep="\t",header=None)
        keep_vec = df_TE[10]
        logging.info("Filter out none TE gene_name according to rmsk file")
        transposon_index_to_keep = df.index.intersection(keep_vec.unique()) #remove duplicated value
        df_filtered = df.loc[transposon_index_to_keep]
    elif mode == "Gene":
        df_TE = pd.read_csv(TE,sep="\t",header=None)
        except_vec = df_TE[10]
        logging.info("Filter out TE gene_name according to rmsk file")
        transposon_index_to_keep = df.index[~df.index.isin(except_vec.unique())]
        df_filtered = df.loc[transposon_index_to_keep]
    else:
        df_filtered = df
    ro.r(f'source("{r_script_path}")')
    logging.info("Convert DataFrame from Python to R ")
    with localconverter(ro.default_converter + pandas2ri.converter):
        r_df = ro.conversion.py2rpy(df_filtered)
    
    logging.info("Call R custom function volcano to plot")
    volcano_r_func = ro.globalenv['volcano']
    volcano_r_func(r_df,outjpeg = f"{out}_{mode}.jpeg")
    


if __name__ == '__main__':
    # indir = "/disk5/luosg/scRNAseq/output/h5ad_QC"
    outdir = "/disk5/luosg/scRNAseq/output/combine"
    samplesDict = { 'Intestine': ['CKO-chang-10XSC3', 'E2-chang-10XSC3', 'TRA-chang-10XSC3', 'WT-chang-10XSC3'],
        'Lung': ['CKO-fei-10XSC3', 'E2-fei-10XSC3', 'TRA-fei-10XSC3', 'WT-fei-10XSC3']}
    # 'Muscle': ['CKO-jirou-10XSC3', 'E2-jirou-10XSC3', 'TRA-jirou-10XSC3', 'WT-jirou-10XSC3']
    ## to bulk adata
    # for group in samplesDict.keys():
    #     adataRaw = ad.read_h5ad(f"{outdir}/{group}/{group}_qc.h5ad")
    #     adataAnn = ad.read_h5ad(f"{outdir}/{group}/{group}_annotate.h5ad")
    #     obs_to_keep = ["celltype", "sample"]
    #     fig_dir = Path(f"{outdir}/{group}/DEG")
    #     fig_dir.mkdir(parents=True, exist_ok=True)
    #     adata = makePseudoBulk(adataRaw,adataAnn,fig_dir=str(fig_dir),out=group,fig_flag=True,obs_to_keep=obs_to_keep,raw_layers = "raw")
    #     adata.write_h5ad(f"{outdir}/{group}/{group}_bulk.h5ad")

    # # #### DEG
    adataDcit = {}
    Intestine = ad.read_h5ad("/disk5/luosg/scRNAseq/output/result/DEG/Intestine/h5ad/Intestine_bulk.h5ad")
    Lung = ad.read_h5ad("/disk5/luosg/scRNAseq/output/result/DEG/Lung/h5ad/Lung_bulk.h5ad")
    # Muscle = ad.read_h5ad("/disk5/luosg/scRNAseq/output/result/DEG/Muscle/h5ad/Muscle_bulk.h5ad")
    adataDcit['Intestine'] = Intestine
    adataDcit['Lung'] = Lung
    # adataDcit['Muscle'] = Muscle
    outdir = Path("/disk5/luosg/scRNAseq/output/combine")
    for tissue,adata in adataDcit.items():
        fig_dir = outdir / f"{tissue}/DEG/plot"
        fig_dir.mkdir(parents=True, exist_ok=True)
        table_dir = outdir /f"{tissue}/DEG/table"
        table_dir.mkdir(parents=True, exist_ok=True)
        main(adata,
            fig_dir=str(fig_dir),
            table_dir=str(table_dir))


    # fileStr = 'combined_group*'
    # outdir = Path("/disk5/luosg/scRNAseq/output/combine")
    # for group in samplesDict.keys():
    #     search_path = outdir / f"{group}/DEG/table"
    #     fig_dir = outdir / f"{group}/DEG/volcano/"
    #     fig_dir.mkdir(parents=True,exist_ok=True)
    #     files = glob.glob(os.path.join(str(search_path), fileStr))
    #     for file in files:
    #         file_name = file.split('.')[0].split('/')[-1]
    #         pattern = r'combined_group(.*)_10XSC3_(.*)-combined_group(.*)_10XSC3_(.*)_DEG'
    #         match = re.match(pattern, file_name)
    #         if match:
    #             experiment = match.group(1)
    #             control = match.group(3)
    #             cell = match.group(2)

    #             Gene_dir = fig_dir / "Gene"
    #             Gene_dir.mkdir(parents=True,exist_ok=True)
    #             outJpeg_Gene = f"{Gene_dir}/{cell}_{experiment}_vs_{control}"
    #             runVolcano(file,outJpeg_Gene,mode="Gene")

    #             TE_dir = fig_dir / "TE"
    #             TE_dir.mkdir(parents=True,exist_ok=True)
    #             outJpeg_TE = f"{TE_dir}/{cell}_{experiment}_vs_{control}"
    #             runVolcano(file,outJpeg_TE,mode="TE")
    #         else:
    #             raise ValueError(f"Filename {file_name} does not match expected pattern.")
    #         # outJpeg = f"{fig_dir}/{file_name}"
    #         # runVolcano(file,outJpeg,mode="TE")
        